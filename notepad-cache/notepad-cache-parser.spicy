module NotepadCache;

import spicy;
%byte-order=spicy::ByteOrder::Big;

# This doesn't support 128bit values... only 64bit. :(
type uLEB128 = unit {
    var xresult: uint64 = 0;
    var shift_width: uint16 = 0;

    : uint8[] &until-including=(($$ & 0x80) == 0) foreach {
        self.xresult += (cast<uint64>($$ & 0x7F) << self.shift_width);
        self.shift_width += 7;
    }
} &convert=self.xresult;

type uLEB128_Timestamp = unit {
    x: uLEB128;
} &convert=(time_ns((self.x-(11644473600 * 10000000))*100));

type OneByteBool = unit {
    x: uint8;
} &convert=(self.x==0 ? False : True);

type WideString = unit(num_chars: uint64) {
    : (uint16)[num_chars] foreach {
        local code_point: uint32 = 0;
        # Decode utf16
        if ( 0xD800 <= $$ && $$ <= 0xDBFF ) {
            # high surrogate
            self.high_surrogate = $$;
            return;
        } else if ( 0xDC00 <= $$ && $$ <= 0xDFFF ) {
            # low surrogate
            code_point = 0x10000 + (cast<uint32>(self.high_surrogate - 0xD800) << 10) + ($$ - 0xDC00);
        } else {
            code_point = $$;
        }

        # Encode utf8
        if ( code_point < 0x80 ) {
            self.utf8 += pack(cast<uint8>(code_point), spicy::ByteOrder::Little);
        } else if ( code_point < 0x800 ) {
            self.utf8 += pack((0xC0 | cast<uint8>(code_point >> 6)), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point & 0x3F)), spicy::ByteOrder::Little);
        } else if ( code_point < 0x10000 ) {
            self.utf8 += pack((0xE0 | cast<uint8>(code_point >> 12)), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point >> 6) & 0x3F), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point & 0x3F)), spicy::ByteOrder::Little);
        } else {
            self.utf8 += pack((0xF0 | cast<uint8>(code_point >> 18)), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point >> 12) & 0x3F), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point >> 6) & 0x3F), spicy::ByteOrder::Little);
            self.utf8 += pack((0x80 | cast<uint8>(code_point & 0x3F)), spicy::ByteOrder::Little);
        }
    }

    var utf8: bytes;
    var high_surrogate: uint16;
} &convert=self.utf8.decode() &byte-order=spicy::ByteOrder::Little;

type Encodings = enum {
    ANSI = 0x01,
    UTF_16LE = 0x02,
    UTF_16BE = 0x03,
    UTF_8BOM = 0x04,
    UTF_8 = 0x05,
};

type LineEndings = enum {
    CRLF = 0x01,
    CR = 0x02,
    LF = 0x03,
};

type ConfigBlock = unit {
    word_wrap: OneByteBool;
    rtl: OneByteBool;
    show_unicode: OneByteBool;
    version: uLEB128;
    unknown: uint16;
};

type UnsavedChunk = unit {
    cursor_position: uLEB128;
    deletion_number: uLEB128;
    addition_number: uLEB128;
    chars: WideString(self.addition_number) {
        # Note how far into the input stream we currently are...
        self.crc_data_len = self.offset();
    }
    var crc_data_len: uint64;
    : bytes &size=self.crc_data_len &parse-at=self.input() {
        self.calculated_crc32 = spicy::crc32_add(spicy::crc32_init(), $$);
    }
    # Ok, now we're caught back to to where we were in the input stream...
    crc32: uint32 {
        self.valid_checksum = (self.calculated_crc32 == $$);
    }
    var calculated_crc32: uint64;
    var valid_checksum: bool;
};

public type File = unit {
    header: b"NP\x00" &synchronize;
    saved: OneByteBool;
    if ( self.saved ) {
        path_length:  uLEB128;
        path:         WideString(self.path_length);
        file_size:    uLEB128;
        encoding:     uint8 &convert=Encodings($$);
        line_endings: uint8 &convert=LineEndings($$);
        last_write:   uLEB128_Timestamp;
        sha256:       bytes &size=32;
        unknown1:     uint8;
    }

    unknown2:        uint8;
    selection_start: uLEB128;
    selection_end:   uLEB128;
    config_block:    ConfigBlock;
    content_length:  uLEB128;
    content:         WideString(self.content_length);
    has_unsaved:     OneByteBool {
        self.crc_data_len = self.offset()-3;
    }
    var crc_data_len: uint64;
    : bytes &size=self.crc_data_len &parse-at=(self.input()+3) {
        self.calculated_crc32 = spicy::crc32_add(spicy::crc32_init(), $$);
    }
    crc32: uint32 {
        self.valid_checksum = (self.calculated_crc32 == $$);
    }
    var calculated_crc32: uint64;
    var valid_checksum: bool;

    unsaved_chunks:  UnsavedChunk[] &eod;
};